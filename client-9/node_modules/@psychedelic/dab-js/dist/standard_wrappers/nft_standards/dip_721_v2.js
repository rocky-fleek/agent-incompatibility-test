"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const agent_1 = require("@dfinity/agent");
const dip_721_v2_did_1 = __importDefault(require("../../idls/dip_721_v2.did"));
const default_1 = __importDefault(require("./default"));
const standards_1 = require("../../constants/standards");
const extractMetadataValue = (metadata) => {
    const metadataKey = Object.keys(metadata)[0];
    const value = metadata[metadataKey];
    return typeof value === 'object' ? JSON.stringify(value) : value;
};
class ERC721 extends default_1.default {
    constructor(canisterId, agent) {
        super(canisterId, agent);
        this.standard = standards_1.NFT.dip721v2;
        this.actor = agent_1.Actor.createActor(dip_721_v2_did_1.default, {
            agent,
            canisterId,
        });
    }
    getUserTokens(principal) {
        return __awaiter(this, void 0, void 0, function* () {
            const userTokensResult = yield this.actor.ownerTokenMetadata(principal);
            const tokens = userTokensResult['Ok'] || [];
            return tokens.map((token) => {
                var _a, _b;
                const tokenIndex = token.token_identifier;
                const formatedMetadata = this.formatMetadata(token);
                const operator = (_b = (_a = token.operator) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toText();
                return this.serializeTokenData(formatedMetadata, tokenIndex, principal.toText(), operator);
            });
        });
    }
    transfer(to, tokenIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const transferResult = yield this.actor.transfer(to, BigInt(tokenIndex));
            if ('Err' in transferResult)
                throw new Error(`${Object.keys(transferResult.Err)[0]}: ${Object.values(transferResult.Err)[0]}`);
        });
    }
    details(tokenIndex) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const metadataResult = yield this.actor.tokenMetadata(BigInt(tokenIndex));
            if ('Err' in metadataResult)
                throw new Error(`${Object.keys(metadataResult.Err)[0]}: ${Object.values(metadataResult.Err)[0]}`);
            const metadata = metadataResult === null || metadataResult === void 0 ? void 0 : metadataResult.Ok;
            const formatedMetadata = this.formatMetadata(metadata);
            const owner = (_c = (_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.owner) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toText) === null || _c === void 0 ? void 0 : _c.call(_b);
            const operator = (_f = (_e = (_d = metadata === null || metadata === void 0 ? void 0 : metadata.operator) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.toText) === null || _f === void 0 ? void 0 : _f.call(_e);
            return this.serializeTokenData(formatedMetadata, tokenIndex, owner, operator);
        });
    }
    serializeTokenData(metadata, tokenIndex, owner, operator) {
        var _a, _b;
        return {
            index: BigInt(tokenIndex),
            canister: this.canisterId,
            metadata,
            owner,
            url: ((_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.location) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.TextContent) || '',
            standard: this.standard,
            operator,
        };
    }
    formatMetadata(metadata) {
        const metadataResult = { properties: new Array() };
        metadata.properties.map((prop) => {
            metadataResult[prop[0]] = { value: prop[1] };
            metadataResult.properties = [
                ...metadataResult.properties,
                { name: prop[0], value: extractMetadataValue(prop[1]) },
            ];
        });
        // Filter out reserved props from the unique traits
        metadataResult.properties = metadataResult.properties.filter(({ name }) => !['location', 'thumbnail', 'contentHash', 'contentType'].includes(name));
        return metadataResult;
    }
}
exports.default = ERC721;
